

# This file was *autogenerated* from the file oracle.sage
from sage.all_cmdline import *   # import sage library

_sage_const_151 = Integer(151); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_0p00001 = RealNumber('0.00001')
# To be redacted
flag = b"quack{50M3T1m35_4Ll_Y0U_n33D_15_4_l1ttl3_150M0rPH15m!}"
#flag = b"quack{150M0rPH15m5!}"

n = _sage_const_151 
#n = 1009
theta = _sage_const_2 *pi/n
a = cos(theta)
b = sin(theta)
bc = _sage_const_2 **(len(flag))-_sage_const_1 

# Provided in challenge description
M = matrix([[a, -b], [b, a]])

def check(M):
  m = (M**n).n() - identity_matrix(_sage_const_2 )
  if m[_sage_const_0 ,_sage_const_0 ]**_sage_const_2 +m[_sage_const_0 ,_sage_const_1 ]**_sage_const_2 +m[_sage_const_1 ,_sage_const_0 ]**_sage_const_2 +m[_sage_const_1 ,_sage_const_1 ]**_sage_const_2  < _sage_const_0p00001 :
    return True
  return False

if check(M) == False:
  print("Please contact the admins about an error")
  quit()
else:
  print("Passed!")
# Encrypt

def encrypt(M, flag):
  i = randint(_sage_const_0 , bc)
  m = [int(j) for j in bin(i)[_sage_const_2 :].zfill(len(flag))]
  res = identity_matrix(_sage_const_2 )
  s = _sage_const_0 
  for c, a in zip(flag, m):
    s += (c*a)%n
    #print(c, s)
    #if a == 0:
    #  continue
    #res *= (M^(c*a)).n()

  #return [i, res.n()]
  return [i, (M**(s % n)).n()]

# SOLUTION
A = matrix(GF(n), _sage_const_0 , len(flag))
b = []

for i in range(_sage_const_2 *len(flag)):
  i, m = encrypt(M, flag)
  alpha = round(arccos(m[_sage_const_0 ,_sage_const_0 ])/theta)

  if m[_sage_const_1 , _sage_const_0 ] < _sage_const_0 :
    b.append(-alpha)
  else:
    b.append(alpha)

  m = [int(j) for j in bin(i)[_sage_const_2 :].zfill(len(flag))]
  A = A.stack(matrix(m))

b = vector(GF(n), b)

print("Solution:")
sol = ''.join([chr(a) for a in A.solve_right(b)])
print(sol)

